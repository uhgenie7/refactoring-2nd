# 메모리 관리

## 1. 가상 메모리

- 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자에게 매우 큰 메모리로 보이게 만드는 것
- 가상 주소: 가상적으로 주어진 주소
  - 메모리관리장치(MMU)에 의해 실제 주소로 변환, 사용자는 실제주소를 의식할 필요없이 프로그램 구축
- 실제 주소: 실제 메모리상에 있는 주소
- 가상 주소와 실제 주소가 매핑되어 있고, 프로세스의 주소 정보가 들어있는 '페이지 테이블'로 관리된다.
- 속도 향상을 위해 TLB를 쓴다.
  > TLB: 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시. 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층.

### 1. 스와핑

- 가상 메모리에는 존재하지만, 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생
- 이를 방지하기 위해 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러와 올리고, 사용하지 않으면 다시 하드디스크로 내림을 반복하여 RAM을 효과적으로 관리하는 것.

### 2. 페이지 폴트

- 프로세스의 주소 공간에는 존재하지만 컴퓨터의 RAM에는 없는 데이터에 접근할 경우 발생
- 운영체제는 해당 데이터를 메모리로 가져와서 페이지 폴트가 발생하지 않은 것처럼 프로그램이 작동하게 해준다
  - CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생해서 운영체제에 알림
  - 운영체제는 CPU의 동작을 잠시 멈춤
  - 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인, 없으면 프로세스를 중지하고 현재 물리 메모리에 빈 프레임이 있는지 찾음.
  - 물리 메모리에도 없다면 스와핑이 발동
  - 비어있는 프레임에 해당 페이지를 로드하고 페이지 테이블을 최신화
  - 중단된 CPU 재시작

## 2. 스레싱

- 메모리의 페이지 폴트율이 높은 것
- 컴퓨터의 성능 저하를 초래함
- 메모리에 너무 많은 프로세스가 동시에 올라가면 스와핑이 많이 일어나서 발생한다
- 페이지 폴트가 일어나면 CPU 이용률이 낮아진다
- CPU 이용률이 낮아지면 운영체제는 가용성을 더 높이기 위해 더 많은 프로세스를 메모리에 올린다.
- 해결방안
  - 메모리 늘리기
  - HDD를 SDD로 바꾸기
  - 운영체제에서 해결하는 방법: 작업세트, PFF

### 1. 작업 세트

- 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드
- 미리 메모리에 로드하면 탐색에 드는 비용이 줄고, 스와핑도 준다

### 2. PFF

- 페이지 폴트 빈도를 조절하는 방법으로, 상한선과 하한선을 만드는 방법
- 상한선에 도달하면 페이지를 늘리고, 하한산에 도달하면 페이지를 줄인다
  > 페이지: 가상 메모리를 사용하는 최소 크기 단위

## 3. 메모리 할당

- 메모리에 프로그램을 할당할 때는 시작 메모리 위치, 메모리의 할당 크기를 기반
- 연속 할당, 불연속 할당으로 나뉜다.

### 1. 연속 할당

- 메모리에 연속적으로 공간을 할당하는 것
- 메모리를 미리 나누어 관리하는 고정 분할 방식, 매 시점 프로그램의 크기에 맞게 메모리를 분할하여 사용하는 가변 분할 방식이 있음

#### 고정 분할 방식

- 메모리를 미리 나누어 관리하는 방식
- 메모리가 미리 나뉘어 있기 때문에 융통성이 없음
- 내부 단편화가 발생

#### 가변 분할 방식

- 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나누어 사용
- 외부 단편화 발생할 수 있음
- 최초적합: 위 혹은 아래부터 시작해서 홀을 찾으면 바로 할당
- 최적접합: 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당
- 최악적합: 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당

### 2. 불연속 할당

- 페이징
  - 메모리를 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스 할당
  - 홀의 크기가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해짐
- 세그멘테이션
  - 의미 단위인 세그먼트로 나누는 방식
  - 공유와 보안 측면에서 좋음
  - 홀 크기가 균일하지 않는 문제
- 페이지드 세그먼테이션
  - 공유나 보안을 의미 단위의 세그먼트로 나눔
  - 물리적 메모리는 페이지로 나눔

## 4. 페이지 교체 알고리즘

- 메모리는 한정되있으므로 스와핑이 많이 일어남

### 1. 오프라인 알고리즘

- 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘
- 사용할 수 없는 알고리즘이지만 다른 알고리즘과의 성능 비교에 대한 기준을 제공함

#### 1. FIFO

- 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법

#### 2. LRU

- 참조가 가장 오래된 페이지를 바꾼다. 오래된 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 함

### 3. LFU

- 가장 참조 횟수가 적은 페이지를 교체함. 많이 사용되지 않는 것을 교체하는 것.
