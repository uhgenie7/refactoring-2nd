## 2. 리팩터링 원칙

### 2.1 리팩터링 정의

- 명사: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
  - 함수 추출하기
  - 조건부 로직을 다형성으로 바꾸기
- 동사: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다.
- 누군가 '리팩터링하다가 코드가 깨져서 고생했다.'라고 한다면 그것은 리팩터링 한 것이 아니다.
- 사용자 관점에서 달라지는 점이 없어야 한다.
- 버그 역시 리팩터링 후에도 그대로 남아 있어야 한다.
- 리팩터링은 성능 최적화와 비슷하다.
  - 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다.
  - **목적이 다르다**
- 리팩터링의 목적: 코드를 이해하고 수정하기 쉽게 만드는 것이다.
- 성능 최적화의 목적: 속도 개선에만 신경쓴다.

### 2.2 두 개의 모자

- 목적을 구분하라.
  - 기능 추가인가?
  - 리팩터링인가?
  - 기능을 추가할 때는 '기능 추가' 모자를 쓴 다음 기존 코드는 절대로 건들지 않고 새 기능을 추가하기만 한다.
    - 진척도는 테스트를 추가해서 통과하는지 확인한다.
  - 리팩터링할 때는 '리팩터링' 모자를 쓴 다음 기능 추가는 절대로 하지 않으며 코드 재구성에만 전념한다.
    - 테스트도 새로 만들지 않는다.
    - 부득이 인터페이스를 변경해야 할 때만 테스트를 추가한다.

### 2.3 리팩터링 하는 이유

- **소프트웨어 설계가 좋아진다**

  - 리팩토링을 통해 내부설계를 파악하기 쉬워진다.
  - 중복 코드 제거를 통해 코드가 고유한 일 수행함을 보장한다.

- **소프트웨어 이해가 쉬워진다**

  - 코드의 목적이 더 잘 드러나게 하여, 본인을 포함한 개발자가 쉽게 유지보수하도록 한다.

- **버그를 쉽게 찾을 수 있다**

  - 리팩토링을하며 프로그램 구조가 명확해지면, 버그가 명확해진다.
  - 프로그래밍 속도를 높일 수 있다
  - 소프트웨어 내부 품질(모듈화의 구현 품질 등)에 따라서 새로운 기능을 추가하는 속도가 달라진다.

### 2.4 언제 리팩터링 해야 할까?

> **3의 법칙**
>
> 1. 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게되면, 계속 한다.
> 3. 비슷한 일을 세 번째로 하게되면, 리팩토링 한다.

- **준비를 위한 리팩토링 : 기능 쉽게 추가하게 만들기**

  - 리팩토링에 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.
  - 현재 코드를 살피며, 구조를 바꾸면 다른 작업을 하기 훨씬 쉬워질 만한 부분을 찾는다.
  - 리팩터링 모자를 쓰고 함수 매개변수화하기를 적용한다.
  - 버그를 잡을 때도 오류를 일으키는 코드가 세곳에 복제되어 퍼져 있다면 한곳으로 합치는 것이 작업하기 편하다.

- **이해를 위한 리팩토링 : 코드를 이해하기 쉽게 만들기**

  코드를 수정 하려면 먼저 코드를 파악해야 한다.

  1. 조건부 로직의 구조가 이상하지 않은가?
  2. 함수 이름이 잘못 지어지지 않은가?

  이후 수정 코드를 테스트해보며 생각이 맞았는지 확인한다.

- **쓰레기 줍기 리팩터링**

  간단하게 수정 가능 한 것은 즉시 고치고, 시간이 걸리는 일은 메모 후 하던 일이 완료되면 처리한다.

- **계획된 리팩터링과 수시로하는 리팩터링**

  - 리팩터링은 따로 시간을 내서 하는 게 아니라, 프로그래밍 과정에 자연스럽게 녹이는 것이다.

- **오래 걸리는 리팩토링**

  - 라이브러리를 새것으로 교체하거나 일부 코드를 다른 팀과 공유하기 위한 컴포넌트 작업 및 의존성 작업은 리팩토링이 장기적으로 걸리기도 한다.
    → 저자는 팀 전체가 리팩터링에 매달리는 것에는 회의적인 입장이다. 리팩토링은 코드를 깨뜨리지 않는다는 장점을 활용하여 누구든지 리팩터링해야 하는 코드와 관련 작업 할 때마다 개선하는 것이 효율적이라 주장한다.

  1. 라이브러리 기존 것과 새 것 모두를 포용하는 추상 인터페이스를 마련한다.
  2. 기존 코드가 이 추상 인터페이스를 호출하도록 한다.
  3. 라이브러리를 교체한다.
     ⇒ 추상화로 갈아타기(Branch By Abstraction)

- **코드 리뷰에 리팩토링 활용하기**

  > **코드리뷰 장점**
  >
  > - 경험이 많은 개발자의 노하우를 적은 개발자에게 전수 할 수 있다.
  > - 대규모 소프트웨어 시스템의 다양한 측면을 많은 사람이 이해하는데 도움
  > - 깔끔한 코드를 작성하는데 도움을 준다.
  > - 다양한 아이디어를 수집할 수 있다.
  > - 리팩토링을 하면 코드 리뷰에 도움이 된다.

  - 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해넣을 수 있는지부터 살펴본다.
  - 쉽다면 실제로 리팩토링한다.
  - 리팩터링은 코드 리뷰 결과를 더 구체적으로 도출하는 데에도 도움이 된다.
  - 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링 하는 것이 가장 좋다
    ⇒ 짝 프로그래밍 (Pair Programming)

- **관리자에게는 뭐라고 말해야 할까?**

  - 관리자가 기술에 정통하고 설계 지구력 가설을 잘 이해하고 있다면 ? 리팩터링에 대해 말하라 : 리팩터링한다고 말하지 말아라.
  - 개발자는 효과적인 소프트웨어를 최대한 빨리 만들 수 있어야 하며, 리팩토링은 빠른 개발을 돕는다.

- **리팩토링하지 말아야 할 때**

  1. 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면
  2. 리팩토링하는 것보다 처음부터 새로 작성하는게 더 쉬울 때

### 2.5 리팩터링 시 고려할 문제

- **새 기능 개발 속도 저하**

  - 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.
  - 오로지 경제적인 이유로 하는 것이다.
  - 리팩터링은 개발 기간을 단축시킨다.

- **코드 소유권**

  - 리팩토링하고자 하는 함수의 코드 소유자가 다른 팀이거나 혹은 함수가 고객에게 API로 제공된 경우 쓰기 권한이 없으므로 리팩토링 시에 문제가 발생하기도 한다.
    - **기존 함수를 유지하고, 함수 본문에서 새 함수를 호출하도록 수정한다.**
    - 인터페이스는 복잡해지지만 클라이언트에 영향을 주지 않을 수 있다.
    - 기존 인터페이스는 폐기 대상으로 지정하고 남겨준다. (미래에 삭제하거나 남긴다)
  - 이처럼 엄격하게 코드 소유권을 관리하면 인터페이스를 관리하느라 시달리게 된다.

  - **코드 소유권을 팀에 두자.**

- **브랜치**

  - **기능 브랜치 방식**

    - 팀원마다 코드베이스의 브랜치에 작업하다가 결과물이 어느정도 쌓이면 마스터 브런치에 통합(trunk)하여 다른 팀원과 공유.
    - 어떤 기능 전체를 한 브랜치에만 구현해놓고 프로덕션 버전으로 릴리스할 때가 되어서야 마스터에 통합하는 경우가 많다.
    - (장) 작업이 끝나지 않은 코드가 마스터에 섞이지 않는다.
    - (장) 기능이 추가될때 마다 버전을 명확히 나눌 수 있다.
    - (장) 기능에 문제가 생기면 쉽게 되돌릴 수 있다.
    - (단) 독립 브랜치로 작업하는 기간이 길어질수록 결과를 마스터로 통합하기 어렵다.
      - 때문에 마스터를 개인 브랜치로 리베이스, 머지한다.

    > **리베이스** — 마스터를 개인 브랜치로 가져와서(pull) 작업한 결과를 다시 마스터에 올리는(push) 양방향 처리. 마스터와 개인 브랜치가 모두 변경됨.
    >
    > **머지** — 마스터를 개인 브랜치로 머지하는 작업하는 단반향 처리

    - 통합 주기를 짧게 잡는다.
    - 지속적 통합 CI 개발 기준으로는 모든 팀원이 하루에 최소 한번은 마스터와 통합한다.
    - 마스터를 항상 건강하게 유지하고, 거대한 기능을 쪼개고, 기능을 끌 수 있는 기능 토글을 적용해야한다. (그렇지 않다면 완료되지 않은 기능이 시스템을 망칠 수 있다.)

- **테스팅**

  - 리팩토링의 특징은 겉보기 동작이 똑같이 유지된다는 것이다.
  - 핵심은 오류를 재빨리 잡는 것이다.
  - 코드의 다양한 측면을 검사하는 test suite가 필요하다.
  - 즉, 자가 테스트 코드를 마련해야 한다.

- **레거시코드**

  - 대규모 레거시 시스템은 테스트 코드 없이 명료하게 리펙토링하기는 어렵다.
  - 즉, 테스트를 보강해야한다.
  - 테스트를 추가할 틈새를 찾아서 시스템을 테스트하자
  - 테스트 없이 진행하기 때문에 상당히 위험하지만 문제를 해결하기 위해서라면 감내해야 한다.
  - 자주 보는 부분을 더 많이 리펙토링하면 이해하기 쉽게 개선할때 얻는 효과도 크다.

### 2-6 리팩터링, 아키택처, 애그니(YAGNI)

- 범용적으로 사용될 것이라고 예측되는 함수를 시나리오 대응을 위한 매개변수로 추가한다.
- 단, 매개변수로를 추가하다보면 쓰임에 비해 함수가 복잡해진다.

  - 미리 추측하지 않고, 요구 사항을 해결하는 소프트웨어를 구축한다.
  - You aren't going to need it (YAGNI)

- **YAGNI**

  - 간결한 설계, 점진적 설계 등으로 불린다.
  - 진화형 아키텍처(evolutionary architecture) 원칙이 발전하는 계기
    - 아키텍처 관련 결정을 시간을 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 수행한다.
  - 아키텍처를 전혀 고려하지 말라는 뜻이 아니고, 아키텍처와 설계를 개발 프로세스에 녹이는 또 다른 방식이다.

### 2-7 리팩터링과 소프트웨어 개발 프로세스

- **XP**

  - xp가 도입되면서 리팩터링이 도입되었다.
  - **지속적 통합**, **자가테스트 코드** 특징을 가진다.
  - 상호의존하는 기법들을 묶은 프로세스라는 특징을 가진다.
    (자가 테스트와 리팩토링을 묶어서 테스트 주도 개발—**TDD** 라고 한다)
  - 최초의 애자일 소프트웨어 방법론 중 하나로 등장했다.

  - 리팩토링의 핵심 실천법은 세 가지로 구성된다.

    1. **자가테스트코드**
    2. **지속적 통합**
    3. **리팩토링 기법**

  - 리팩토링의 첫 번째 토대는 **자가 테스트 코드**이다.
    - 프로그래밍 중 발생 오류를 테스트로 자동 수행 할 수 있어야 한다.
    - 팀으로 개발하면서 리팩터링하려면 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링 할 수 있어야한다.
    - **지속적 통합**을 통해 리팩터링 결과를 빠르게 공유하여 삭제될 인터페이스에 기능 추가하는 일을 방지하고, 팀내 작업 문제 발생시 즉시 알아낼 수 있다.

### 2-8 리팩터링과 성능

- 리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이다.
- 하지만, 성능을 튜닝하기 더 쉬워진다.
