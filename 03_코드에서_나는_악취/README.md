## 3.1 기이한 이름

마땅한 이름이 떠오르지 않으면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

## 3.2 중복 코드

**함수 추출하기:** 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우, 양쪽 모두 추출된 메서드를 호출하게 바꾼다.
**문장 슬라이드하기:** 코드가 비슷하나, 완전히 똑같지 않다면 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용한다.
**메서드 올리기:** 같은 부모로부터 파생된 서브 클래스에 코드가 중복되어 있다면 각자 따로 호출되지 않도록 적용

## 3.3 긴 함수

간접 호출의 효과: 코드가 끝없이 위임하는 방식. 함수를 짧게 구성한다.
코드를 읽는 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 하므로 부담스럽다.
-> 좋은 이름을 지어두면 본문 코드를 볼 이유가 없다.

- 주석을 달아야 할 만한 부분은 무조건 함수로 만든다.
- 동작 방식이 아닌 '의도', '목적'이 드러나게 짓는다.
- '무엇을 하는지' 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.

**함수 추출하기:** 함수를 짧게 만드는 작업의 대부분. 함수 본문에서 따로 묶어 빼내면 좋은 코드 덩어리를 찾아 새로운 함수로 만든다.
주석은 코드만으로 목적을 이해하기 어려운 부분에 달린다.
함수 이름은 주석 내용을 토대로 짓는다.

## 3.4 긴 매개변수 목록

- 매개변수를 질의 함수로 바꾸기
  - 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드 :객체 통째로 넘기기
  - 항상 함께 전달되는 매개변수들 : 매개변수 객체 만들기
  - 함수의 동작 방식을 정하는 플래그역할의 매개변수: 플래그 인수 제거하기
- 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 : 여러 함수를 클래스로 묶기를 사용하여 공통 값들을 클래스의 필드로 정의

## 3.5 전역 데이터

버그가 발생해도 문제의 원인이 되는 코드를 찾아내기가 굉장히 어렵다.
전역 데이터의 대표적인 형태는 전역 변수이지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.

- 변수 캡슐화하기
  - 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용한다.
    함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.
  - 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄인다.

전역 데이터가 가변이면 특히나 다루기 까다롭다.

## 3.6 가변 데이터

- 불시에 변경될 수 있고 변경의 추적이 어렵다. 전역 데이터와 같은 맥락.

1. 무분별한 데이터 수정에 따른 사이드 이펙트 발생 위험이 높아질 때
2. 구조체의 내부 필드에 변수가 있는 경우

캡슐화를 통해 변수 수정에 대해 삼시를 수월하게 하기
변수를 갱신하는 코드들의 유효범위를 제한한다.

**결국 데이터의 변경을 인지하고 제어가능할 수 있어야 한다**

### 3.7 뒤엉킨 변경

- 단일 책임 원칙(SRP)가 제대로 지켜지지 않을 때 나타난다.
  - 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생!

### 3.8 산탄총 수술

- 뒤엉킨 변경과 비슷하면서도 정반대의 개념.
- 하나의 기능 A를 담당하는 부분이 코드베이스 전반에 퍼져 있다고 할 수 있음
- 산탄총 수술은 코드를 변경(1)할 때마다 자잘하게 수정해야 하는 클래스(n)가 많을 때 냄새가 납니다.
- 함수 옮기기와 필드 옮기기 등 으로 한 모듈에 묶어두어 해결

### 3.9 기능 편애

기능 편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 **다른 모듈의 함수나 데이터와 상호작용할 일이 더 많은 때 풍기는 냄새.**

- 해당 함수를 데이터 근처로 함수 옮기기
- 함수의 일부 부분만 편애할 경우 해당 부분만 독립 함수로 함수 추출하기

중요한건 함께 변경할 대상을 한데 모으는 것이다.

### 3.10 데이터 뭉치

데이터 항목 서너개가 여러 곳에서 항상 함께 뭉쳐 다닌다면, 데이터 클래스로 묶어줘야 한다.

추후 데이터 클래스에 로직이 붙으면 유용한 클래스가 탄생하는 결과로 이어지기도 합니다.

### 3.11 기본형 집착

대부분의 프로그래밍 언어는 다양한 기본 자료형을 제공한다.

화폐, 좌표, 구간 등의 기초타입이 필요하다면 직업 정의해서 사용하도록 하자

### 3.12 반복되는 switch문

switch문은 모조리 조건부 로직을 다형성으로 바꾸기로 없애야 할 대상은 아니다.

중복된 switch문이 문제가 되는 이유는 **조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정**해야 하기 때문이다.

위의 이유에 해당하는 switch문은 다형성을 사용하여 최신 스타일의 코드베이스로 바꿔주도록 하자.

### 3.13 반복문

일급함수를 지원하는 언어가 많아졌기 때문에 반복문을 파이프라인으로 바꾸기를 적용하여 반복문 사용을 지양하도록하자.

filter or map과 같은 파이프라인 연산을 사용하면 각 원소들이 어떻게 처리되는지도 쉽게 파악할 수 있다.

하지만 어디든 예외는 있으니 파이프라인 연산이 필요한지 아닌지 판단할 수 있는 능력을 갖추자

### 3.14 성의 없는 요소

- 의미 없는 한줄짜리 함수, 메서드가 하나 뿐인 클래스 등이 해당한다.
- 함수 인라인하기, 클래스 인라인하기로 제거하도록하자.

**의미가 있느냐 없느냐가 제거 판단의 기준이 됨**

### 3.15 추측성 일반화

- '나중에 필요할 거야'라는 생각으로 당장 필요없는 모든 종류의 후킹 포인트와 케이스 처리 로직을 작성해두는 경우.
- 나중에 쓰면 좋지만, 안쓴다면 낭비일 뿐이다. 당장 걸리적거리는 코드는 눈앞에서 치워버리자

ex) 하는 일이 거의 없는 함수나 클래스

### 3.16 임시 필드

- 객체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하는게 보통이라, 특정 상황에서만 값이 존재하는 임시 필드는 코드를 이해하기 어렵게 한다.
- 클래스 추출하기로 임시 필드를 제거해준다.
- null 객체 때문에 임시필드가 발생하는 경우라면 널 객체를 따로 정의해준다.

### 3.17 메시지 체인

- 클라이언트가 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 경우, 객체 내비게이션 구조에 종속되어 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정되는 상황이 벌어진다.
- 위임 숨기기, 함수 추출하기, 함수 옮기기 등을 이용해 해결해보도록 한다

### 3.18 중개자

- 객체의 대표적인 기능 하나로, 외부로부터 세부사항을 숨겨주는 캡슐화가 있다.
- 캡슐화하는 과정에서는 위임이 자주 활용된다.
- 사소한 세부사항은 숨기고 캡슐화하기 위한 수단 중 하나
- 하지만 해당 클래스의 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 중개자를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자

### 3.19 내부자 거래

- 모듈들 사이에 결합도가 너무 높아지게 되는 것 같다면, 함수 옮기기, 필드 옮기기 등을 이용해서 클래스들끼리 사적으로 처리하는 부분을 줄인다.
- 부모-자식 상속 구조에서 더 이상 수용이 안되는 경우, 서브클래스를 위임으로 바꾸기나 슈퍼클래스를 위임으로 바꾸기를 활용하자.

### 3.20 거대한 클래스

한 클래스가 너무 많은 일을 할 때

- 필드 수가 너무 많아진 클래스
  - 클래스 추출하기, 슈퍼클래스 추출하기, 서브클래스 추출하기
- 코드량이 너무 많은 클래스
  - 중복 제거
- 클라이언트 호출 패턴에서 기능 그룹을 묶을 단서를 얻은 뒤, 클래스 분리

### 3.21 서로 다른 인터페이스의 대안 클래스들

- 인터페이스 같아야하기 때문에 메서드 시그니처를 일치시키고, 필요한 동작들을 위해 함수를 메서드 안으로 옮기면서 대안 클래스를 만들고, 때로는 대안 클래스들을 위한 슈퍼클래스를 생성하도록 한다.
- 대안 클래스(구현 클래스)들 사이에 중복이 발생하면, 슈퍼클래스 추출하기를 적용할지 고려.

### 3.22 데이터 클래스

데이터 클래스란, 데이터 필드와 Getter/Setter로만 이루어진 클래스를 말한다.

- public 필드는 캡슐화 해주고, 변경하면 안되는 필드는 세터 제거하기.
- 불변 필드는 굳이 캡슐화 할 필요가 없고, 게터를 통하지 않고 그냥 필드 자체를 공개해도 된다.
- **한편, 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수 있다.**

> DTO(Data Transfer Object) : 계층 간 데이터 교환을 하기 위해 사용하는 객체로, DTO는 로직을 가지지 않는 순수한 데이터 객체(getter & setter 만 가진 클래스)

### 3.23 상속 포기

- 서브클래스에서, 상속 받은 멤버가 필요 없을 때
- 예전에는 계층 구조를 잘못 설계했기 때문으로 봤다. ⇒ 공통되지 않은 항목은 모두 서브클래스로.
- 하지만 지금은 항상 위와 같이 해야한다고 생각하지는 않는다.
  일부 동작을 재활용하기 위한 목적으로 상속을 활용 하는 것은 실무 관점에서 유용한 방식이기 때문.
- 상속을 위임으로 바꾸기 를 고려해볼 수 있다.

### 3.24 주석

- 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.
- 특정 코드 블럭이 하는 일에 주석을 남기고 싶다면 함수 추출하기를 적용해보고, 이미 추출한 함수임에도 여전히 설명이 필요하다면 함수 선언 바꾸기를 사용해본다.
- 어떤 동작을 위한 선행조건을 명시하고 싶다면 어서션 추가하기를 사용해본다.
- 그 밖에 주석이 필요한 경우
  - 현재 진행 상황
  - 확실하지 않은 상황에 대해서
  - 이렇게 코드를 작성한 이유
